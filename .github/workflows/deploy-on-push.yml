name: Deploy changed .cfg files via SFTP

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      run_mode:
        description: 'Run mode: "changed" (only files changed in the push) or "full" (upload all tracked .cfg files under REPO_PREFIX).'
        required: false
        default: 'full'
      dry_run:
        description: 'If "true", only print actions (no ssh/scp). Useful for testing.'
        required: false
        default: 'true'
      ref:
        description: 'Branch/ref to checkout when running manually (optional).'
        required: false
        default: 'main'

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      # Path inside your repo that contains the .cfg files you want to deploy
      REPO_PREFIX: 'addons/sourcemod/configs/stripper'
      VERBOSE: 'true'

      # Server 1 (required for initial testing)
      SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
      SERVER1_USER: ${{ secrets.SERVER1_USER }}
      SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
      SERVER1_REMOTE_BASE: ${{ secrets.SERVER1_REMOTE_BASE }}
      SERVER1_PORT: ${{ secrets.SERVER1_PORT }}

      # Server 2 (optional)
      SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
      SERVER2_USER: ${{ secrets.SERVER2_USER }}
      SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
      SERVER2_REMOTE_BASE: ${{ secrets.SERVER2_REMOTE_BASE }}
      SERVER2_PORT: ${{ secrets.SERVER2_PORT }}

      # Server 3 (optional)
      SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
      SERVER3_USER: ${{ secrets.SERVER3_USER }}
      SERVER3_PASS: ${{ secrets.SERVER3_PASS }}
      SERVER3_REMOTE_BASE: ${{ secrets.SERVER3_REMOTE_BASE }}
      SERVER3_PORT: ${{ secrets.SERVER3_PORT }}

    steps:
      - name: "Checkout repository (full history)"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Optionally checkout requested ref (workflow_dispatch)"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.ref != '' }}
        run: |
          REF="${{ github.event.inputs.ref }}"
          echo "workflow_dispatch requested ref: $REF"
          git fetch origin "$REF" --depth=1 || true
          git checkout "$REF" || git checkout -b "$REF" "origin/$REF" || true

      - name: "Install sshpass (for password-based non-interactive sftp/scp)"
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: "Debug: show tracked files & prefix (always runs, safe)"
        run: |
          echo "REPO_PREFIX = '${REPO_PREFIX}'"
          echo "Current Git branch:"
          git rev-parse --abbrev-ref HEAD || true
          echo
          echo "Top 200 tracked files:"
          git ls-files | sed -n '1,200p' || true
          echo
          echo "Files matching REPO_PREFIX (${REPO_PREFIX}):"
          git ls-files | grep -E -i "^${REPO_PREFIX}(/|$)" || true
          echo
          if [ -d "${REPO_PREFIX}" ]; then
            echo "Local dir ${REPO_PREFIX} exists — listing:"
            ls -la "${REPO_PREFIX}" || true
          else
            echo "Local dir ${REPO_PREFIX} does not exist."
          fi

      - name: "Determine changed .cfg files (robust + verbose)"
        id: changed
        env:
          RUN_MODE: ${{ github.event.inputs.run_mode }}
          BEFORE: ${{ github.event.before }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          RUN_MODE="${RUN_MODE:-changed}"
          BEFORE="${BEFORE}"
          AFTER="${AFTER}"
          echo "RUN_MODE=$RUN_MODE"
          echo "BEFORE=$BEFORE"
          echo "AFTER=$AFTER"
          echo "REPO_PREFIX='${REPO_PREFIX}'"
          REPO_PREFIX="${REPO_PREFIX%/}"

          # Ensure we have relevant commits locally
          git fetch --no-tags --prune origin || true
          if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git fetch origin "$BEFORE":"refs/remotes/origin/$BEFORE" || true
          fi
          if [ -n "$AFTER" ]; then
            git fetch origin "$AFTER":"refs/remotes/origin/$AFTER" || true
          fi

          # Show files in AFTER commit (debug)
          echo "Files in AFTER commit (top 200):"
          git ls-tree -r --name-only "${AFTER}" | sed -n '1,200p' || true
          echo "----"

          # Build changed.txt (group pipelines and redirect their output)
          if [ "$RUN_MODE" = "full" ] || [ -z "$BEFORE" ] || [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            echo "FULL mode or initial commit — listing all .cfg files under REPO_PREFIX in AFTER commit"
            (git ls-tree -r --name-only "${AFTER}" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true
          else
            echo "CHANGED mode — raw diff between BEFORE and AFTER:"
            git --no-pager diff --name-only "$BEFORE" "$AFTER" | sed -n '1,200p' || true
            (git --no-pager diff --name-only "$BEFORE" "$AFTER" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true

            if [ ! -s changed.txt ]; then
              echo "Diff returned no .cfg files; falling back to listing .cfg files from AFTER commit under prefix"
              (git ls-tree -r --name-only "${AFTER}" \
                | grep -E -i "^${REPO_PREFIX}(/|$)" \
                | grep -E -i '\.cfg$') > changed.txt || true
            fi
          fi

          if [ ! -f changed.txt ]; then
            touch changed.txt
          fi

          echo "Final changed .cfg files (changed.txt):"
          sed -n '1,200p' changed.txt || true
          echo "Count: $(wc -l < changed.txt || true)"
          echo "files=$(wc -l < changed.txt || true)" >> "$GITHUB_OUTPUT"

      - name: "Upload / remove changed .cfg files to configured servers (debug)"
        if: ${{ always() }}
        env:
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          set -euo pipefail
          DRY_RUN="${DRY_RUN:-true}"
          REPO_PREFIX="${REPO_PREFIX%/}"

          echo ">>> Printing changed.txt"
          if [ -f changed.txt ]; then
            nl -ba changed.txt || true
          else
            echo "changed.txt missing"
          fi
          echo "----"

          while IFS= read -r f || [ -n "$f" ]; do
            [ -z "$f" ] && continue
            echo "Processing: '$f'"

            case "$f" in
              "$REPO_PREFIX" | "$REPO_PREFIX/"* )
                if [ "$f" = "$REPO_PREFIX" ]; then
                  relpath="$(basename "$f")"
                else
                  relpath="${f#${REPO_PREFIX}/}"
                fi
                ;;
              *)
                echo "  -> Skipping because not under REPO_PREFIX"
                continue
                ;;
            esac

            echo "  relpath = '$relpath'"

            if ! echo "$relpath" | grep -E -i '\.cfg$' >/dev/null 2>&1; then
              echo "  -> Skipping because not a .cfg file"
              continue
            fi

            # Show whether file exists in workspace and its stat
            if [ -e "$f" ]; then
              echo "  File exists in workspace: $(ls -l "$f" 2>/dev/null || echo 'ls failed')"
            else
              echo "  File DOES NOT exist in workspace path '$f'"
            fi

            # Show git presence check
            if git --no-pager ls-files --error-unmatch "$f" >/dev/null 2>&1; then
              echo "  Present in index/commit"
            else
              echo "  NOT present in index/commit"
            fi

            # For each configured server, print what we'd do
            for i in 1 2 3; do
              HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
              if [ -z "$HOST" ]; then
                continue
              fi
              USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
              USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-22}"
              if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                echo "  Server $i missing USER/PASS/REMOTE_BASE — skipping"
                continue
              fi

              target="${REMOTE_BASE%/}/$relpath"
              if [ -f "$f" ]; then
                if [ "$DRY_RUN" = "true" ]; then
                  echo "  [DRY] Would upload to server${i}: $HOST ($USER) -> $target"
                else
                  echo "  Uploading to server${i}: $HOST ($USER) -> $target"
                  sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "mkdir -p '$(dirname "$target")'"
                  sshpass -p "$PASS" scp -P "${PORT:-22}" -p "$f" "$USER@$HOST:$target"
                fi
              else
                if [ "$DRY_RUN" = "true" ]; then
                  echo "  [DRY] Would remove remote file on server${i}: $target (local file missing)"
                else
                  echo "  Removing remote file on server${i}: $target"
                  sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "rm -f '$target' || true"
                fi
              fi
            done

            echo "----"
          done < changed.txt

      - name: "Summary"
        if: ${{ always() }}
        run: |
          echo "Workflow finished. Check above logs for upload/remove actions."
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "This was a dry run. Set 'dry_run' input to 'false' in workflow_dispatch to perform real uploads."
          fi