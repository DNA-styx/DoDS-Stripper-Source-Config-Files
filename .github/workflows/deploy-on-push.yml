name: Deploy changed .cfg files via SFTP (push-only, path-filtered, conditional ports)

on:
  push:
    branches:
      - main
    paths:
      - 'addons/sourcemod/configs/stripper/**'

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      # Path in the repo containing the .cfg files to deploy
      REPO_PREFIX: 'addons/sourcemod/configs/stripper'

      # Server 1 (required)
      SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
      SERVER1_USER: ${{ secrets.SERVER1_USER }}
      SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
      SERVER1_REMOTE_BASE: ${{ secrets.SERVER1_REMOTE_BASE }}
      SERVER1_PORT: ${{ secrets.SERVER1_PORT }}

      # Server 2 (optional)
      SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
      SERVER2_USER: ${{ secrets.SERVER2_USER }}
      SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
      SERVER2_REMOTE_BASE: ${{ secrets.SERVER2_REMOTE_BASE }}
      SERVER2_PORT: ${{ secrets.SERVER2_PORT }}

      # Server 3 (optional)
      SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
      SERVER3_USER: ${{ secrets.SERVER3_USER }}
      SERVER3_PASS: ${{ secrets.SERVER3_PASS }}
      SERVER3_REMOTE_BASE: ${{ secrets.SERVER3_REMOTE_BASE }}
      SERVER3_PORT: ${{ secrets.SERVER3_PORT }}

    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install sshpass
        run: |
          sudo apt-get update -y
          sudo apt-get install -y sshpass

      - name: Determine changed .cfg files
        id: changed
        env:
          BEFORE: ${{ github.event.before }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          REPO_PREFIX="${REPO_PREFIX%/}"
          BEFORE="${BEFORE}"
          AFTER="${AFTER}"

          # Ensure commits are available
          git fetch --no-tags --prune origin || true
          if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git fetch origin "$BEFORE":"refs/remotes/origin/$BEFORE" || true
          fi
          if [ -n "$AFTER" ]; then
            git fetch origin "$AFTER":"refs/remotes/origin/$AFTER" || true
          fi

          # Get changed .cfg files between BEFORE and AFTER
          git --no-pager diff --name-only "$BEFORE" "$AFTER" \
            | grep -E -i "^${REPO_PREFIX}(/|$)" \
            | grep -E -i '\.cfg$' > changed.txt || true

          # Fallback: list all .cfg files under prefix in AFTER commit
          if [ ! -s changed.txt ]; then
            git ls-tree -r --name-only "${AFTER}" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$' > changed.txt || true
          fi

          touch changed.txt
          echo "Changed files (changed.txt):"
          sed -n '1,200p' changed.txt || true
          echo "files=$(wc -l < changed.txt || true)" >> "$GITHUB_OUTPUT"

      - name: Upload / remove changed .cfg files (from commit)
        if: ${{ always() }}
        env:
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          REPO_PREFIX="${REPO_PREFIX%/}"
          AFTER="${AFTER}"

          if [ ! -s changed.txt ]; then
            echo "No .cfg files to process; exiting."
            exit 0
          fi

          while IFS= read -r f || [ -n "$f" ]; do
            [ -z "$f" ] && continue

            # compute relpath relative to REPO_PREFIX
            case "$f" in
              "$REPO_PREFIX" | "$REPO_PREFIX/"* )
                if [ "$f" = "$REPO_PREFIX" ]; then
                  relpath="$(basename "$f")"
                else
                  relpath="${f#${REPO_PREFIX}/}"
                fi
                ;;
              *)
                echo "Skipping (not under REPO_PREFIX): $f"
                continue
                ;;
            esac

            # only handle .cfg files
            if ! echo "$relpath" | grep -E -i '\.cfg$' >/dev/null 2>&1; then
              echo "Skipping (not .cfg): $f"
              continue
            fi

            # If file exists in AFTER commit, extract and upload. Otherwise remove remote.
            if git cat-file -e "${AFTER}:$f" 2>/dev/null; then
              echo "Uploading ${f} -> ${relpath}"
              tmpf="$(mktemp)" || (echo "mktemp failed" && exit 1)
              if ! git show "${AFTER}:$f" > "$tmpf"; then
                echo "git show failed for ${f}; skipping"
                rm -f "$tmpf"
                continue
              fi

              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                [ -z "$HOST" ] && continue
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-}"

                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "Server $i missing credentials or remote base; skipping"
                  continue
                fi

                remote_target="${REMOTE_BASE%/}/$relpath"
                remote_dir="$(dirname "$remote_target")"

                # Build conditional port arguments only when PORT is set
                SSH_PORT_ARG=""
                SCP_PORT_ARG=""
                if [ -n "$PORT" ]; then
                  SSH_PORT_ARG="-p $PORT"
                  SCP_PORT_ARG="-P $PORT"
                fi

                # create remote directory and upload using conditional port args
                sshpass -p "$PASS" ssh $SSH_PORT_ARG -o StrictHostKeyChecking=no "$USER@$HOST" "mkdir -p '$remote_dir'"
                sshpass -p "$PASS" scp $SCP_PORT_ARG -p "$tmpf" "$USER@$HOST:$remote_target"
                echo "  -> uploaded to $HOST:$remote_target"
              done

              rm -f "$tmpf"

            else
              echo "Removing remote: ${f} (not present in AFTER)"
              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                [ -z "$HOST" ] && continue
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-}"

                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "Server $i missing credentials or remote base; skipping"
                  continue
                fi

                remote_target="${REMOTE_BASE%/}/$relpath"

                SSH_PORT_ARG=""
                if [ -n "$PORT" ]; then
                  SSH_PORT_ARG="-p $PORT"
                fi

                sshpass -p "$PASS" ssh $SSH_PORT_ARG -o StrictHostKeyChecking=no "$USER@$HOST" "rm -f '$remote_target' || true"
                echo "  -> removed $HOST:$remote_target"
              done
            fi

          done < changed.txt

      - name: Summary
        run: |
          echo "Workflow finished. Processed files listed in changed.txt."