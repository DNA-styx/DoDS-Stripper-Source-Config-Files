name: Deploy changed .cfg files via SFTP

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      run_mode:
        description: 'Run mode: "changed" (only files changed in the push) or "full" (upload all tracked .cfg files under REPO_PREFIX).'
        required: false
        default: 'full'
      dry_run:
        description: 'If "true", only print actions (no ssh/scp). Useful for testing.'
        required: false
        default: 'true'
      ref:
        description: 'Branch/ref to checkout when running manually (optional).'
        required: false
        default: 'main'

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      # Path inside your repo that contains the .cfg files to deploy
      REPO_PREFIX: 'addons/sourcemod/configs/stripper'
      VERBOSE: 'true'

      # Server 1 (required for initial testing)
      SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
      SERVER1_USER: ${{ secrets.SERVER1_USER }}
      SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
      SERVER1_REMOTE_BASE: ${{ secrets.SERVER1_REMOTE_BASE }}
      SERVER1_PORT: ${{ secrets.SERVER1_PORT }}

      # Server 2 (optional)
      SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
      SERVER2_USER: ${{ secrets.SERVER2_USER }}
      SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
      SERVER2_REMOTE_BASE: ${{ secrets.SERVER2_REMOTE_BASE }}
      SERVER2_PORT: ${{ secrets.SERVER2_PORT }}

      # Server 3 (optional)
      SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
      SERVER3_USER: ${{ secrets.SERVER3_USER }}
      SERVER3_PASS: ${{ secrets.SERVER3_PASS }}
      SERVER3_REMOTE_BASE: ${{ secrets.SERVER3_REMOTE_BASE }}
      SERVER3_PORT: ${{ secrets.SERVER3_PORT }}

    steps:
      - name: "Checkout repository (full history)"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Optionally checkout requested ref (workflow_dispatch)"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.ref != '' }}
        run: |
          REF="${{ github.event.inputs.ref }}"
          echo "workflow_dispatch requested ref: $REF"
          git fetch origin "$REF" --depth=1 || true
          git checkout "$REF" || git checkout -b "$REF" "origin/$REF" || true

      - name: "Install sshpass (for password-based non-interactive sftp/scp)"
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: "Debug: show tracked files & prefix (always runs, safe)"
        run: |
          echo "REPO_PREFIX = '${REPO_PREFIX}'"
          echo "Current Git branch:"
          git rev-parse --abbrev-ref HEAD || true
          echo
          echo "Top 200 tracked files:"
          git ls-files | sed -n '1,200p' || true
          echo
          echo "Files matching REPO_PREFIX (${REPO_PREFIX}):"
          git ls-files | grep -E -i "^${REPO_PREFIX}(/|$)" || true
          echo
          if [ -d "${REPO_PREFIX}" ]; then
            echo "Local dir ${REPO_PREFIX} exists — listing:"
            ls -la "${REPO_PREFIX}" || true
          else
            echo "Local dir ${REPO_PREFIX} does not exist."
          fi

      - name: "Determine changed .cfg files (robust + verbose)"
        id: changed
        env:
          RUN_MODE: ${{ github.event.inputs.run_mode }}
          BEFORE: ${{ github.event.before }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          RUN_MODE="${RUN_MODE:-changed}"
          BEFORE="${BEFORE}"
          AFTER="${AFTER}"
          echo "RUN_MODE=$RUN_MODE"
          echo "BEFORE=$BEFORE"
          echo "AFTER=$AFTER"
          echo "REPO_PREFIX='${REPO_PREFIX}'"
          REPO_PREFIX="${REPO_PREFIX%/}"

          # Ensure we have relevant commits locally
          git fetch --no-tags --prune origin || true
          if [ -n "$BEFORE" ] && [ "$BEFORE" != "0000000000000000000000000000000000000000" ]; then
            git fetch origin "$BEFORE":"refs/remotes/origin/$BEFORE" || true
          fi
          if [ -n "$AFTER" ]; then
            git fetch origin "$AFTER":"refs/remotes/origin/$AFTER" || true
          fi

          echo "Files in AFTER commit (top 200):"
          git ls-tree -r --name-only "${AFTER}" | sed -n '1,200p' || true
          echo "----"

          # Build changed.txt (capture pipeline output safely)
          if [ "$RUN_MODE" = "full" ] || [ -z "$BEFORE" ] || [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            echo "FULL mode or initial commit — listing all .cfg files under REPO_PREFIX in AFTER commit"
            (git ls-tree -r --name-only "${AFTER}" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true
          else
            echo "CHANGED mode — raw diff between BEFORE and AFTER:"
            git --no-pager diff --name-only "$BEFORE" "$AFTER" | sed -n '1,200p' || true
            (git --no-pager diff --name-only "$BEFORE" "$AFTER" \
              | grep -E -i "^${REPO_PREFIX}(/|$)" \
              | grep -E -i '\.cfg$') > changed.txt || true

            if [ ! -s changed.txt ]; then
              echo "Diff returned no .cfg files; falling back to listing .cfg files from AFTER commit under prefix"
              (git ls-tree -r --name-only "${AFTER}" \
                | grep -E -i "^${REPO_PREFIX}(/|$)" \
                | grep -E -i '\.cfg$') > changed.txt || true
            fi
          fi

          if [ ! -f changed.txt ]; then
            touch changed.txt
          fi

          echo "Final changed .cfg files (changed.txt):"
          sed -n '1,500p' changed.txt || true
          echo "Count: $(wc -l < changed.txt || true)"
          echo "files=$(wc -l < changed.txt || true)" >> "$GITHUB_OUTPUT"

      - name: "Upload / remove changed .cfg files to configured servers (from commit content)"
        if: ${{ always() }}
        env:
          DRY_RUN: ${{ github.event.inputs.dry_run }}
          AFTER: ${{ github.sha }}
        run: |
          set -euo pipefail
          DRY_RUN="${DRY_RUN:-true}"
          REPO_PREFIX="${REPO_PREFIX%/}"
          AFTER="${AFTER}"

          if [ ! -f changed.txt ] || [ ! -s changed.txt ]; then
            echo "No .cfg files matched under prefix '$REPO_PREFIX'. Nothing to do."
            exit 0
          fi

          echo ">>> changed.txt contents:"
          nl -ba changed.txt || true
          echo "----"

          while IFS= read -r f || [ -n "$f" ]; do
            [ -z "$f" ] && continue
            echo "Processing: '$f'"

            case "$f" in
              "$REPO_PREFIX" | "$REPO_PREFIX/"* )
                if [ "$f" = "$REPO_PREFIX" ]; then
                  relpath="$(basename "$f")"
                else
                  relpath="${f#${REPO_PREFIX}/}"
                fi
                ;;
              *)
                echo "  -> Skipping because not under REPO_PREFIX"
                continue
                ;;
            esac

            echo "  relpath = '$relpath'"

            # Sanity-check: only .cfg files
            if ! echo "$relpath" | grep -E -i '\.cfg$' >/dev/null 2>&1; then
              echo "  -> Skipping because not a .cfg file"
              continue
            fi

            # Determine presence in commit/index
            if git --no-pager ls-files --error-unmatch "$f" >/dev/null 2>&1; then
              echo "  Present in commit — uploading from commit object"
              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                if [ -z "$HOST" ]; then
                  continue
                fi
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-22}"
                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "  Server $i missing USER/PASS/REMOTE_BASE — skipping"
                  continue
                fi

                remote_target="${REMOTE_BASE%/}/$relpath"
                remote_dir="$(dirname "$remote_target")"

                if [ "$DRY_RUN" = "true" ]; then
                  echo "  [DRY] Would ensure remote dir on server${i}: $HOST -> $remote_dir"
                  echo "  [DRY] Would upload file to server${i}: $remote_target"
                else
                  # Create remote directory
                  sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "mkdir -p '$remote_dir'"

                  # Write file from commit to a temp file and scp it
                  tmpf="$(mktemp)"
                  if git show "${AFTER}:$f" > "$tmpf" 2>/dev/null; then
                    sshpass -p "$PASS" scp -P "${PORT:-22}" -p "$tmpf" "$USER@$HOST:$remote_target"
                    echo "  Uploaded to server${i}: $remote_target"
                    rm -f "$tmpf"
                  else
                    echo "  ERROR: git show failed for ${AFTER}:$f — skipping server${i}"
                    rm -f "$tmpf"
                  fi
                fi
              done
            else
              echo "  NOT present in commit (deleted) — removing remote file on configured servers"
              for i in 1 2 3; do
                HOST_VAR="SERVER${i}_HOST"; HOST="${!HOST_VAR:-}"
                if [ -z "$HOST" ]; then
                  continue
                fi
                USER_VAR="SERVER${i}_USER"; PASS_VAR="SERVER${i}_PASS"; RB_VAR="SERVER${i}_REMOTE_BASE"; PORT_VAR="SERVER${i}_PORT"
                USER="${!USER_VAR:-}"; PASS="${!PASS_VAR:-}"; REMOTE_BASE="${!RB_VAR:-}"; PORT="${!PORT_VAR:-22}"
                if [ -z "$USER" ] || [ -z "$PASS" ] || [ -z "$REMOTE_BASE" ]; then
                  echo "  Server $i missing USER/PASS/REMOTE_BASE — skipping"
                  continue
                fi
                remote_target="${REMOTE_BASE%/}/$relpath"
                if [ "$DRY_RUN" = "true" ]; then
                  echo "  [DRY] Would remove remote file on server${i}: $remote_target"
                else
                  sshpass -p "$PASS" ssh -p "${PORT:-22}" -o StrictHostKeyChecking=no "$USER@$HOST" "rm -f '$remote_target' || true"
                  echo "  Removed remote file on server${i}: $remote_target"
                fi
              done
            fi

            echo "----"
          done < changed.txt

      - name: "Summary"
        if: ${{ always() }}
        run: |
          echo "Workflow finished. Check logs above for upload/remove actions."
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "This was a dry run. To perform real uploads, run this workflow with dry_run = 'false'."
          fi